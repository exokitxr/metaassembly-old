<!doctype html>
<html>
<head>
<script src="https://rawcdn.githack.com/ConsenSys/eth-lightwallet/d21df74dd2d5e09632bf38309f147784668b1498/dist/lightwallet.js"></script>
<style>
body {
  display: flex;
  height: 100vh;
  margin: 0;
  flex-direction: column;
}
header {
  display: flex;
  flex-direction: column;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}
h1 {
  padding: 0 30px;
}
a {
  text-decoration: underline;
  color: #64b5f6;
  cursor: pointer;
}
a:active {
  color: #1e88e5;
}
form {
  display: none;
  flex-direction: column;
}
body.phase-1 #form-1,
body.phase-2 #form-2
{
  display: block;
}
</style>
</head>
<body class=phase-1>
  <header>
    <h1>Metachromium Lite</h1>
    <form id=form-1>
      <textarea id=seed-phrase placeholder="seed phrase">announce beef fever pipe connect laptop assault space gorilla dad uphold broccoli</textarea>
      <input type=password id=password value=password>
      <input type=submit>
    </form>
    <form id=form-2>
      <input type=button id=enter-xr-button value="Enter XR">
      <input type=button id=enter-overlay-button value="Enter Overlay">
    </form>
  </header>
  <canvas id=canvas></canvas>
<script type=module>
  import THREE from './three.module.js';
  window.THREE = THREE;
</script>
<script type=module>
import {OrbitControls} from './OrbitControls.js';
import {XRControllerModelFactory} from './XRControllerModelFactory.js';
import {initLocalRig, updatePlayerFromCamera, updatePlayerFromXr, updatePlayerFromArrays, getRigBoneTexture, bindPeerConnection} from './peerconnection.js';

function makePromise() {
  let accept, reject;
  const p = new Promise((a, r) => {
    accept = a;
    reject = r;
  });
  p.accept = accept;
  p.reject = reject;
  return p;
}
function base64ArrayBuffer(arrayBuffer, byteOffset = 0, byteLength = arrayBuffer.byteLength) {
  var base64    = ''
  var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

  var bytes         = new Uint8Array(arrayBuffer)
  var byteLength    = bytes.byteLength
  var byteRemainder = byteLength % 3
  var mainLength    = byteLength - byteRemainder

  var a, b, c, d
  var chunk

  // Main loop deals with bytes in chunks of 3
  for (var i = 0; i < mainLength; i = i + 3) {
    // Combine the three bytes into a single integer
    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

    // Use bitmasks to extract 6-bit segments from the triplet
    a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
    b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
    c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
    d = chunk & 63               // 63       = 2^6 - 1

    // Convert the raw binary segments to the appropriate ASCII encoding
    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
  }

  // Deal with the remaining bytes and padding
  if (byteRemainder == 1) {
    chunk = bytes[mainLength]

    a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

    // Set the 4 least significant bits to zero
    b = (chunk & 3)   << 4 // 3   = 2^2 - 1

    base64 += encodings[a] + encodings[b] + '=='
  } else if (byteRemainder == 2) {
    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

    a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
    b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

    // Set the 2 least significant bits to zero
    c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

    base64 += encodings[a] + encodings[b] + encodings[c] + '='
  }
  
  return base64
}

const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias: true,
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
renderer.physicallyCorrectLights = true;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFShadowMap;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xEEEEEE);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0.5, 2);
camera.rotation.order = 'YXZ';
renderer.render(scene, camera);

const ambientLight = new THREE.AmbientLight(0xFFFFFF);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight.position.set(0.5, 1, 0.5).multiplyScalar(100);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.width = 1024;
directionalLight.shadow.mapSize.height = 1024;
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = 500;
scene.add(directionalLight);

const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight2.position.set(-0.5, -0.1, 0.5).multiplyScalar(100);
scene.add(directionalLight2);

const container = new THREE.Object3D();
scene.add(container);

const orbitControls = new OrbitControls(camera, canvas, document);
orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, 0, -1.5));
orbitControls.screenSpacePanning = true;
// orbitControls.enabled = !!loginToken;
orbitControls.enableMiddleZoom = false;
orbitControls.update();

initLocalRig(container);

const socket = new WebSocket(`ws://localhost:3000/`);
socket.onopen = async () => {
  console.log('socket open', socket);

  /* const result = await socket.request('test', [
    new ArrayBuffer(8)
  ]);
  console.log('got result', result); */
};
const cbs = [];
socket.onmessage = m => {
  m = JSON.parse(m.data);
  const cb = cbs.shift();
  cb && cb(m);
};
socket.onclose = () => {
  console.log('socket close', socket);
};
socket.request = async (method, args) => {
  const bins = [];
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg instanceof ArrayBuffer || ArrayBuffer.isView(arg)) {
      bins.push(arg);
      args[i] = null;
    }
  }

  const p = makePromise();
  cbs.push(o => {
    const {error, result} = o;
     if (!error) {
       p.accept(result);
     } else {
       p.reject(error);
     }
  });
  socket.send(JSON.stringify({
    method,
    args,
  }));
  for (let i = 0; i < bins.length; i++) {
    socket.send(bins[i]);
  }
  return await p;
};

window.addEventListener('load', async e => {
  const enterXrButton = document.getElementById('enter-xr-button');
  let currentSession = null;
  const triggerDowns = [false, false];
  const gripDowns = [false, false];
  let scaleState = null;
  const lastSqueezes = [false, false];
  function onSessionStarted(session) {
    session.addEventListener('end', onSessionEnded);

    renderer.xr.setSession(session);

    currentSession = session;

    const controllerModelFactory = new XRControllerModelFactory();
    for (let i = 0; i < 2; i++) {
      const controller = renderer.xr.getController(i);
      controller.addEventListener('connected', e => {
        controller.userData.data = e.data;
      });
      controller.addEventListener('selectstart', e => {
        if (controller.userData.data && controller.userData.data.handedness === 'right') {
          _beginTool(true, false, false);
        }
        triggerDowns[i] = true;
      });
      controller.addEventListener('selectend', e => {
        if (controller.userData.data && controller.userData.data.handedness === 'right') {
          _endTool(true, false, false);
        }
        triggerDowns[i] = false;
      });

      const controllerGrip = renderer.xr.getControllerGrip(i);
      controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
      controllerGrip.addEventListener('squeezestart', e => {
        if (controller.userData.data && controller.userData.data.handedness === 'right') {
          _beginTool(false, true, false);
        }
        const oldGripDownsAll = gripDowns.every(gripDown => gripDown);
        gripDowns[i] = true;
        const newGripDownsAll = gripDowns.every(gripDown => gripDown);
        if (newGripDownsAll && !oldGripDownsAll) {
          _commitMiningMeshes();
          
          scaleState = {
            startPosition: renderer.xr.getControllerGrip(0).position.clone()
              .add(renderer.xr.getControllerGrip(1).position)
              .divideScalar(2),
            startDirection: renderer.xr.getControllerGrip(0).position.clone()
              .sub(renderer.xr.getControllerGrip(1).position)
              .normalize(),
            startWorldWidth: renderer.xr.getControllerGrip(0).position
              .distanceTo(renderer.xr.getControllerGrip(1).position),
            containerStartPosition: container.position.clone(),
            containerStartQuaternion: container.quaternion.clone(),
            containerStartScale: container.scale.clone(),
            containerStartMatrix: container.matrix.clone(),
          };
        }
      });
      controllerGrip.addEventListener('squeezeend', e => {
        if (controller.userData.data && controller.userData.data.handedness === 'right') {
          _endTool(false, true, false);
        }
        gripDowns[i] = false;
        const newGripDownsAll = gripDowns.every(gripDown => gripDown);
        if (!newGripDownsAll) {
          scaleState = null;
        }
      });
      scene.add(controllerGrip);
    }
  }
  function onSessionEnded() {
    currentSession.removeEventListener('end', onSessionEnded);

    currentSession = null;
  }
  enterXrButton.addEventListener('click', e => {
    e.preventDefault();
    e.stopPropagation();
    
    if (currentSession === null) {
      // WebXR's requestReferenceSpace only works if the corresponding feature
      // was requested at session creation time. For simplicity, just ask for
      // the interesting ones as optional features, but be aware that the
      // requestReferenceSpace call will fail if it turns out to be unavailable.
      // ('local' is always available for immersive sessions and doesn't need to
      // be requested separately.)
      var sessionInit = {
        optionalFeatures: [
          'local-floor',
          'bounded-floor',
        ],
      };
      navigator.xr.requestSession('immersive-vr', sessionInit).then(onSessionStarted);
    } else {
      currentSession.end();
    }
  });

  const velocity = new THREE.Vector3();
  function animate() {
    orbitControls.enabled && orbitControls.update();

    if (currentSession) {
      /* for (let i = 0; i < 2; i++) {
        const controller = renderer.xr.getController(i);
        if (controller.userData.data) {
          if (controller.userData.data.handedness === 'left') {
            uiMesh.position.copy(controller.position);
            uiMesh.quaternion.copy(controller.quaternion);
          } else if (controller.userData.data.handedness === 'right') {
            _updateRaycasterFromObject(localRaycaster, controller);
            _updateTool(localRaycaster);
          }
        }
      }

      _updateControllers(); */

      updatePlayerFromXr(renderer.xr, camera);
    } /* else {
      const speed = 0.015 * (keys.shift ? 3 : 1);
      const cameraEuler = camera.rotation.clone();
      cameraEuler.x = 0;
      cameraEuler.z = 0;
      const extraVelocity = new THREE.Vector3();
      if (keys.left) {
        extraVelocity.add(new THREE.Vector3(-1, 0, 0).applyEuler(cameraEuler));
      }
      if (keys.right) {
        extraVelocity.add(new THREE.Vector3(1, 0, 0).applyEuler(cameraEuler));
      }
      if (keys.up) {
        extraVelocity.add(new THREE.Vector3(0, 0, -1).applyEuler(cameraEuler));
      }
      if (keys.down) {
        extraVelocity.add(new THREE.Vector3(0, 0, 1).applyEuler(cameraEuler));
      }
      if (extraVelocity.length() > 0) {
        extraVelocity.normalize().multiplyScalar(speed);
      }
      velocity.add(extraVelocity);
      camera.position.add(velocity);
      velocity.multiplyScalar(0.7);
      
      orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, 0, -1.5).applyQuaternion(camera.quaternion));
      
      updatePlayerFromCamera(camera);
    } */

    /* for (let i = 0; i < peerConnections.length; i++) {
      const peerConnection = peerConnections[i];
      peerConnection.rig && peerConnection.rig.update();
    }

    tickObjectScript(objectState);

    if (ammo) {
      ammo.simulate();
      for (let i = 0; i < objectMeshes.length; i++) {
        ammo.updateObjectMesh(objectMeshes[i]);
      }
    } */

    /* const thirdperson = selectedTool === 'thirdperson';
    let oldCameraPosition;
    if (thirdperson) {
      oldCameraPosition = camera.position.clone();
      camera.position.add(new THREE.Vector3(0, 0, 2).applyQuaternion(camera.quaternion));
    } */
    renderer.render(scene, camera);
    /* if (thirdperson) {
      camera.position.copy(oldCameraPosition);
    } */
  }
  renderer.setAnimationLoop(animate);

  navigator.xr && navigator.xr.isSessionSupported('immersive-vr').then(supported => {
    if (supported) {
      renderer.xr.enabled = true;
      enterXrButton.classList.remove('disabled');
    } else {
      // nothing
    }
  });

  /* window.addEventListener('pose', e => {
    console.log('got first pose', e.data);
  }, {once: true}); */

  document.getElementById('form-1').addEventListener('submit', e => {
    e.preventDefault();

    // the seed is stored encrypted by a user-defined password
    var password = document.getElementById('password').value;
    var seedPhrase = document.getElementById('seed-phrase').value;
    // var seedPhrase = lightwallet.keystore.generateRandomSeed();

    lightwallet.keystore.createVault({
      password,
      seedPhrase, // Optionally provide a 12-word seed phrase
      // salt: fixture.salt,     // Optionally provide a salt.
                                 // A unique salt will be generated otherwise.
      hdPathString: `m/44'/60'/0'/0`,    // Optional custom HD Path String
    },
    function (err, ks) {
      console.log('got keystore', ks);

      // Some methods will require providing the `pwDerivedKey`,
      // Allowing you to only decrypt private keys on an as-needed basis.
      // You can generate that value with this convenient method:
      ks.keyFromPassword(password, function (err, pwDerivedKey) {
        if (err) throw err;

        // generate five new address/private key pairs
        // the corresponding private keys are also encrypted
        ks.generateNewAddress(pwDerivedKey, 5);
        var addr = ks.getAddresses();

        ks.passwordProvider = function (callback) {
          var pw = prompt("Please enter password", "Password");
          callback(null, pw);
        };

        // Now set ks as transaction_signer in the hooked web3 provider
        // and you can start using web3 using the keys/addresses in ks!
      });
    });

    for (let i = 1; i <= 2; i++) {
      document.body.classList.remove(`phase-${i}`);
    }
    document.body.classList.add('phase-2');
  });
  document.getElementById('form-2').addEventListener('submit', e => {
    e.preventDefault();

    for (let i = 1; i <= 2; i++) {
      document.body.classList.remove(`phase-${i}`);
    }
    document.body.classList.add('phase-2');
  });
  let avatarObject = null;
  let hmdObject = null;
  const controllerObjects = [null, null];
  document.getElementById('enter-overlay-button').addEventListener('click', async e => {
    await socket.request('startRenderer', []);
    console.log('render started');
    
    /* {
      if (
        methodString == "addObject" &&
        args.size() >= 5 &&
        args[0].is_string() &&
        args[1].is_string() &&
        args[2].is_string() &&
        args[3].is_string() &&
        args[4].is_string()
      ) {
        std::vector<float> positions = Base64::Decode<float>(args[0].get<std::string>());
        std::vector<float> normals = Base64::Decode<float>(args[1].get<std::string>());
        std::vector<float> colors = Base64::Decode<float>(args[2].get<std::string>());
        std::vector<float> uvs = Base64::Decode<float>(args[3].get<std::string>());
        std::vector<uint16_t> indices = Base64::Decode<uint16_t>(args[4].get<std::string>());

        std::string name("object");
        name += std::to_string(++ids);

        models[name] = app->renderer->m_renderer->createDefaultModelInstance(name);
        app->renderer->m_renderer->addToRenderList(models[name].get());
        // std::shared_ptr<vkglTF::Model> VulkanExample::findOrLoadModel( std::string modelUri, std::string *psError)
        
        json result = {
          {"id", name}
        };
        json res = {
          {"error", nullptr},
          {"result", result}
        };
        respond(res);
      } else if (
        methodString == "updateObjectTransform" &&
        args.size() >= 4 &&
        args[0].is_string() &&
        args[1].is_string() &&
        args[2].is_string() &&
        args[3].is_string()
      ) {
        std::string name = args[0].get<std::string>();
        std::vector<float> position = Base64::Decode<float>(args[1].get<std::string>());
        std::vector<float> quaternion = Base64::Decode<float>(args[2].get<std::string>());
        std::vector<float> scale = Base64::Decode<float>(args[3].get<std::string>());

        auto model = models[name].get();
        app->renderer->m_renderer->setModelTransform(models[name].get(), position, quaternion, scale);
        // XXX update geometry
        
        json result = {
          // {"processId", processId}
        };
        json res = {
          {"error", nullptr},
          {"result", result}
        };
        respond(res);
      } else if (
        methodString == "updateObjectGeometry" &&
        args.size() >= 6 &&
        args[0].is_string() &&
        args[1].is_string() &&
        args[2].is_string() &&
        args[3].is_string() &&
        args[4].is_string() &&
        args[5].is_string()
      ) {
        std::string name = args[0].get<std::string>();
        std::vector<float> positions = Base64::Decode<float>(args[1].get<std::string>());
        std::vector<float> normals = Base64::Decode<float>(args[2].get<std::string>());
        std::vector<float> colors = Base64::Decode<float>(args[3].get<std::string>());
        std::vector<float> uvs = Base64::Decode<float>(args[4].get<std::string>());
        std::vector<uint16_t> indices = Base64::Decode<uint16_t>(args[5].get<std::string>());

        models[name] = app->renderer->m_renderer->setModelGeometry(std::move(models[name]), positions, normals, colors, uvs, indices);
        
        json result = {
          // {"processId", processId}
        };
        json res = {
          {"error", nullptr},
          {"result", result}
        };
        respond(res);
      }
    } */
    const geometry = new THREE.CylinderBufferGeometry(0, 0.1, 0.1, 3, 1);
    const colors = new Float32Array(geometry.attributes.position.array.length);
    for (let i = 0; i < colors.length; i += 3) {
      colors[i+2] = 1;
    }
    /* hmdObject = await socket.request('addObject', [
      base64ArrayBuffer(geometry.attributes.position.array.buffer, geometry.attributes.position.array.byteOffset, geometry.attributes.position.array.byteLength),
      base64ArrayBuffer(geometry.attributes.normal.array.buffer, geometry.attributes.normal.array.byteOffset, geometry.attributes.normal.array.byteLength),
      base64ArrayBuffer(colors.buffer, colors.byteOffset, colors.byteLength),
      base64ArrayBuffer(geometry.attributes.uv.array.buffer, geometry.attributes.uv.array.byteOffset, geometry.attributes.uv.array.byteLength),
      base64ArrayBuffer(geometry.index.array.buffer, geometry.index.array.byteOffset, geometry.index.array.byteLength),
    ]); */
    controllerObjects[0] = await socket.request('addObject', [
      base64ArrayBuffer(geometry.attributes.position.array.buffer, geometry.attributes.position.array.byteOffset, geometry.attributes.position.array.byteLength),
      base64ArrayBuffer(geometry.attributes.normal.array.buffer, geometry.attributes.normal.array.byteOffset, geometry.attributes.normal.array.byteLength),
      base64ArrayBuffer(colors.buffer, colors.byteOffset, colors.byteLength),
      base64ArrayBuffer(geometry.attributes.uv.array.buffer, geometry.attributes.uv.array.byteOffset, geometry.attributes.uv.array.byteLength),
      base64ArrayBuffer(geometry.index.array.buffer, geometry.index.array.byteOffset, geometry.index.array.byteLength),
    ]);
    controllerObjects[1] = await socket.request('addObject', [
      base64ArrayBuffer(geometry.attributes.position.array.buffer, geometry.attributes.position.array.byteOffset, geometry.attributes.position.array.byteLength),
      base64ArrayBuffer(geometry.attributes.normal.array.buffer, geometry.attributes.normal.array.byteOffset, geometry.attributes.normal.array.byteLength),
      base64ArrayBuffer(colors.buffer, colors.byteOffset, colors.byteLength),
      base64ArrayBuffer(geometry.attributes.uv.array.buffer, geometry.attributes.uv.array.byteOffset, geometry.attributes.uv.array.byteLength),
      base64ArrayBuffer(geometry.index.array.buffer, geometry.index.array.byteOffset, geometry.index.array.byteLength),
    ]);
    console.log('got objects', hmdObject, controllerObjects[0], controllerObjects[1]);
    
    const res = await fetch('../data/avatar.glb');
    const arrayBuffer = await res.arrayBuffer();
    console.log('model fetched');
    avatarObject = await socket.request('addModel', [
      'model',
      base64ArrayBuffer(arrayBuffer),
    ]);
    console.log('model added');
  });
  window.addEventListener('pose', e => {
    const {hmd, left, right} = e.data;
    if (avatarObject) {
      updatePlayerFromArrays(renderer.xr, hmd, left, right);
      const boneTexture = getRigBoneTexture();
      if (boneTexture) {
        // console.log('submit bones', boneTexture);
        socket.request('updateObjectBoneTexture', [
          avatarObject.id,
          base64ArrayBuffer(boneTexture.buffer, boneTexture.byteOffset, boneTexture.byteLength),
        ]);
      }
    }
    /* if (hmdObject) {
      const hmdArray = Float32Array.from(hmd);
      socket.request('updateObjectMatrix', [
        hmdObject.id,
        base64ArrayBuffer(hmdArray.buffer, hmdArray.byteOffset, hmdArray.byteLength),
      ]);
    } */
    if (controllerObjects[0]) {
      const leftArray = Float32Array.from(left);
      socket.request('updateObjectMatrix', [
        controllerObjects[0].id,
        base64ArrayBuffer(leftArray.buffer, leftArray.byteOffset, leftArray.byteLength),
      ]);
    }
    if (controllerObjects[1]) {
      const rightArray = Float32Array.from(right);
      socket.request('updateObjectMatrix', [
        controllerObjects[1].id,
        base64ArrayBuffer(rightArray.buffer, rightArray.byteOffset, rightArray.byteLength),
      ]);
    }
  });
});

</script>
</body>
</html>