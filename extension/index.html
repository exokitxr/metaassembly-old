<!doctype html>
<html>
<head>
  <link href="index.css" rel=stylesheet>
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700&display=swap" rel="stylesheet">
  <script src="https://kit.fontawesome.com/0735724151.js" crossorigin="anonymous"></script>
  <script src="https://www.gstatic.com/firebasejs/7.9.2/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/7.9.2/firebase-database.js"></script>
  <script src="https://rawcdn.githack.com/ethereum/web3.js/a6ddec59e65116853435f203b25cb9c55824d084/dist/web3.min.js"></script>
  <script src="https://rawcdn.githack.com/ConsenSys/eth-lightwallet/d21df74dd2d5e09632bf38309f147784668b1498/dist/lightwallet.js"></script>
</head>
<body>
  <header id=header>
    <!-- <a href="https://browser.exokit.org">
      <img class=icon src="logo.svg"/>
    </a> -->
    <a href="/" class="nav open" id="explore-dropdown">ムらサ</a>
    <!-- <a href="/" class="nav open" id="explore-dropdown">Augment</a> -->
    <div class="room disconnected">
      <div class="connect-status disconnected">Multiplayer disconnected</div>
      <div class=button id=create-room-button>Create room</div>
      <div class=button id=use-code-button>Use code</div>
    </div>
    <div class="room dialog">
      <div class="connect-status disconnected">Multiplayer disconnected</div>
      <input type=text id=room-code-input placeholder="Enter room code">
      <div class=button id=connect-button>Connect</div>
      <div class=button id=cancel-connect-button>Cancel</div>
    </div>
    <div class="room connected">
      <div class=users><i class="fa fa-user"></i> <span id=user-count-text>1</span></div>
      <div class=room-code>Room code: <span class=room-code-text id=room-code-text></span> Link: <a href="#" target="_blank" class=room-link id=room-link><i class="fa fa-external-link"></i></a></div>
      <div class=button id=disconnect-button>Disconnect</div>
    </div>
    <div class=tools>
      <a id=tool-1 class="tool selected" tool="orbit">
        <i class="fal fa-camera"></i>
        <div class=label>Camera tool</div>
      </a>
      <a id=tool-2 class="tool" tool="firstperson">
        <i class="fal fa-eye"></i>
        <div class=label>First person</div>
      </a>
      <a id=tool-3 class="tool" tool="thirdperson">
        <i class="fal fa-walking"></i>
        <div class=label>Third person</div>
      </a>
    </div>
    <div class="addressbook">
      <input type=text class=address-input id=address-input placeholder="0x0000000000000000000000000000000000000000" autocomplete=fake>
      <a class=button id=add-address-button>+ Add</a>
      <div class=addresses id=addresses></div>
    </div>
    <div class="wallet none">
      <div class=address>No wallet</div>
      <div class=button id=import-key-button>Import key</div>
      <div class=button id=create-wallet-button>Create wallet</div>
    </div>
    <div class="wallet import">
      <input type=text id=seed-phrase-input placeholder="seed phrase">
      <input type=password id=password-input placeholder="password">
      <div class=button id=import-button>Log in</div>
      <div class=button id=cancel-import-button>Cancel</div>
    </div>
    <div class="wallet locked">
      <div class=address>Wallet locked</div>
      <input type=password id=password-unlock-input placeholder="password">
      <div class=button id=unlock-wallet-button>Unlock</div>
      <div class=button id=forget-wallet-button>Forget</div>
    </div>
    <div class="wallet unlocked">
      <div class=address id=address-text></div>
      <div class=balance id=balance-text></div>
      <div class=button id=download-key-button>D/L key</div>
      <div class=button id=lock-wallet-button>Lock</div>
    </div>
    <div class="xr">
      <div class=button id=enter-xr-button>Enter XR</div>
      <div class=button id=enter-overlay-button>Enter AR</div>
    </div>
  </header>
  <canvas id=canvas></canvas>
<!-- <body class=phase-1>
  <header>
    <h1>Metachromium Lite</h1>
    <form id=form-1>
      <textarea id=seed-phrase placeholder="seed phrase">announce beef fever pipe connect laptop assault space gorilla dad uphold broccoli</textarea>
      <input type=password id=password value=password>
      <input type=submit>
    </form>
    <form id=form-2>
      <input type=button id=enter-xr-button value="Enter XR">
      <input type=button id=enter-overlay-button value="Enter Overlay">
    </form>
  </header>
  <canvas id=canvas></canvas> -->
<script type=module>
import THREE from './three.module.js';
window.THREE = THREE;
</script>
<script type=module>
import {OrbitControls} from './OrbitControls.js';
import {GLTFLoader} from './GLTFLoader.js';
import {XRControllerModelFactory} from './XRControllerModelFactory.js';
import {makeId, XRChannelConnection} from './multiplayer.js';
import {initLocalRig, updatePlayerFromCamera, updatePlayerFromXr, updatePlayerFromArrays, updatePlayerDefault, getRigBoneTexture, bindPeerConnection} from './peerconnection.js';

const network = 'rinkeby';
const infuraApiKey = '4fb939301ec543a0969f3019d74f80c2';
const rpcUrl = `https://${network}.infura.io/v3/${infuraApiKey}`;
const web3 = new Web3(new Web3.providers.HttpProvider(rpcUrl));
window.web3 = web3;

function makePromise() {
  let accept, reject;
  const p = new Promise((a, r) => {
    accept = a;
    reject = r;
  });
  p.accept = accept;
  p.reject = reject;
  return p;
}
/* function base64ArrayBuffer(arrayBuffer, byteOffset = 0, byteLength = arrayBuffer.byteLength) {
  var base64    = ''
  var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

  var bytes         = new Uint8Array(arrayBuffer)
  var byteLength    = bytes.byteLength
  var byteRemainder = byteLength % 3
  var mainLength    = byteLength - byteRemainder

  var a, b, c, d
  var chunk

  // Main loop deals with bytes in chunks of 3
  for (var i = 0; i < mainLength; i = i + 3) {
    // Combine the three bytes into a single integer
    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

    // Use bitmasks to extract 6-bit segments from the triplet
    a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
    b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
    c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
    d = chunk & 63               // 63       = 2^6 - 1

    // Convert the raw binary segments to the appropriate ASCII encoding
    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
  }

  // Deal with the remaining bytes and padding
  if (byteRemainder == 1) {
    chunk = bytes[mainLength]

    a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

    // Set the 4 least significant bits to zero
    b = (chunk & 3)   << 4 // 3   = 2^2 - 1

    base64 += encodings[a] + encodings[b] + '=='
  } else if (byteRemainder == 2) {
    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

    a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
    b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

    // Set the 2 least significant bits to zero
    c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

    base64 += encodings[a] + encodings[b] + encodings[c] + '='
  }
  
  return base64
} */

const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias: true,
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
renderer.physicallyCorrectLights = true;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFShadowMap;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xEEEEEE);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0.5, 2);
camera.rotation.order = 'YXZ';
renderer.render(scene, camera);

const ambientLight = new THREE.AmbientLight(0xFFFFFF);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight.position.set(0.5, 1, 0.5).multiplyScalar(100);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.width = 1024;
directionalLight.shadow.mapSize.height = 1024;
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = 500;
scene.add(directionalLight);

const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight2.position.set(-0.5, 0.1, 0.5).multiplyScalar(100);
scene.add(directionalLight2);

const container = new THREE.Object3D();
scene.add(container);

const orbitControls = new OrbitControls(camera, canvas, document);
orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, 0, -1.5));
orbitControls.screenSpacePanning = true;
// orbitControls.enabled = !!loginToken;
orbitControls.enableMiddleZoom = false;
orbitControls.update();

const defaultGltf = new THREE.Object3D();
container.add(defaultGltf);
const _loadDefaultGltf = () => {
  const loader = new GLTFLoader();
  loader.load('sketch.gltf', object => {
    console.log('loaded object', object);
    object = object.scene;

    defaultGltf.add(object);
    defaultGltf.position.set(-0.5, 0, -1);
    defaultGltf.scale.setScalar(2);
  }, xhr => {
    // console.log('progress');
  }, err => {
    console.warn(err);
  });
};
_loadDefaultGltf();

let rig = null;
let currentSession = null;
initLocalRig()
  .then(newRig => {
    rig = newRig;

    if (cameraMode === 'firstperson' || currentSession) {
      rig.decapitate();
    }
    container.add(rig.model);
  });

// tools

const keys = {
  up: false,
  down: false,
  left: false,
  right: false,
  shift: false,
};
(() => {
  const w = window;
  w.addEventListener('keydown', e => {
    switch (e.which) {
      case 49: // 1
      case 50:
      case 51: // 3
      {
        tools[e.which - 49].click();
        break;
      }
      case 87: { // W
        if (!document.pointerLockElement) {
          // nothing
        } else {
          keys.up = true;
        }
        break;
      }
      case 65: { // A
        if (!document.pointerLockElement) {
          // nothing
        } else {
          keys.left = true;
        }
        break;
      }
      case 83: { // S
        if (!document.pointerLockElement) {
          // nothing
        } else {
          keys.down = true;
        }
        break;
      }
      case 68: { // D
        if (!document.pointerLockElement) {
          // nothing
        } else {
          keys.right = true;
        }
        break;
      }
      case 16: { // shift
        if (document.pointerLockElement) {
          keys.shift = true;
        }
        break;
      }
    }
  });
  w.addEventListener('keyup', e => {
    switch (e.which) {
      case 87: { // W
        if (document.pointerLockElement) {
          keys.up = false;
        }
        break;
      }
      case 65: { // A
        if (document.pointerLockElement) {
          keys.left = false;
        }
        break;
      }
      case 83: { // S
        if (document.pointerLockElement) {
          keys.down = false;
        }
        break;
      }
      case 68: { // D
        if (document.pointerLockElement) {
          keys.right = false;
        }
        break;
      }
      case 16: { // shift
        if (document.pointerLockElement) {
          keys.shift = false;
        }
        break;
      }
    }
  });
  w.addEventListener('mousemove', e => {
    if (document.pointerLockElement) {
      const {movementX, movementY} = e;
      camera.rotation.y -= movementX * Math.PI*2*0.001;
      camera.rotation.x -= movementY * Math.PI*2*0.001;
    }
  });
})();

const tools = document.querySelectorAll('.tool');
Array.from(tools).forEach((tool, i) => {
  /* tool.addEventListener('mousedown', e => {
    e.stopPropagation();
  }); */
  tool.addEventListener('click', e => {
    e.preventDefault();
    e.stopPropagation();

    const newTool = tool.getAttribute('tool');
    if (newTool !== cameraMode) {
      Array.from(tools).forEach(tool => {
        tool.classList.remove('selected');
      });
      cameraMode = newTool;
      tool.classList.add('selected');
    }

    if (cameraMode === 'orbit') {
      document.pointerLockElement && document.exitPointerLock();
      orbitControls.enabled = true;
    } else if (cameraMode === 'firstperson' || cameraMode === 'thirdperson') {
      renderer.domElement.requestPointerLock();
      camera.position.y = 1.2;
      orbitControls.enabled = false;
    } else {
      document.pointerLockElement && document.exitPointerLock();
      orbitControls.enabled = false;
    }
    if (rig) {
      if (cameraMode === 'firstperson' || currentSession) {
        rig.decapitate();
      } else {
        rig.undecapitate();
      }
    }
  });
});
document.addEventListener('pointerlockchange', e => {
  if (!document.pointerLockElement) {
    Array.from(tools).find(tool => tool.matches('.tool[tool=orbit]')).click();
  }
});
let cameraMode = 'orbit';

// interface

const _makeUiMesh = ({uiWidth, uiHeight, uiWorldWidth, uiWorldHeight}) => {
  const geometry = new THREE.PlaneBufferGeometry(uiWorldWidth, uiWorldHeight);
  const canvas = document.createElement('canvas');
  canvas.width = uiWidth;
  canvas.height = uiHeight;
  const ctx = canvas.getContext('2d');
  const imageData = ctx.createImageData(uiWidth, uiHeight);
  const texture = new THREE.Texture(
    canvas,
    THREE.UVMapping,
    THREE.ClampToEdgeWrapping,
    THREE.ClampToEdgeWrapping,
    THREE.LinearFilter,
    THREE.LinearMipMapLinearFilter,
    THREE.RGBAFormat,
    THREE.UnsignedByteType,
    16,
    THREE.LinearEncoding
  );
  const material = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide,
    transparent: true,
    alphaTest: 0.5,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.visible = false;
  mesh.frustumCulled = false;
  
  const highlightMesh = (() => {
    const geometry = new THREE.BoxBufferGeometry(1, 1, 0.01);
    const material = new THREE.MeshBasicMaterial({
      color: 0x42a5f5,
      transparent: true,
      opacity: 0.5,
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.frustumCulled = false;
    mesh.visible = false;
    return mesh;
  })();
  mesh.add(highlightMesh);

  let anchors = [];
  let hoveredAnchor = null;
  mesh.update = async () => {
    const result = await mesh.onupdate();
    
    imageData.data.set(result.data);
    ctx.putImageData(imageData, 0, 0);
    texture.needsUpdate = true;
    mesh.visible = true;
    
    anchors = result.anchors;
  };
  mesh.intersect = uv => {
    hoveredAnchor = null;
    highlightMesh.visible = false;

    if (uv) {
      uv.y = 1 - uv.y;
      uv.x *= uiWidth;
      uv.y *= uiHeight;

      for (let i = 0; i < anchors.length; i++) {
        const anchor = anchors[i];
        const {top, bottom, left, right, width, height} = anchor;
        if (uv.x >= left && uv.x < right && uv.y >= top && uv.y < bottom) {
          hoveredAnchor = anchor;
          
          highlightMesh.position.x = -uiWorldWidth/2 + (left + width/2)/uiWidth*uiWorldWidth;
          highlightMesh.position.y = uiWorldHeight/2 - (top + height/2)/uiHeight*uiWorldHeight;
          highlightMesh.scale.x = width/uiWidth*uiWorldWidth;
          highlightMesh.scale.y = height/uiHeight*uiWorldHeight;
          highlightMesh.visible = true;
          return true;
          // break;
        }
      }
    }
    return false;
  };
  mesh.press = () => {
    return mesh.onpress(hoveredAnchor);
  };
  Promise.resolve().then(() => {
    mesh.update();
  });

  return mesh;
};
const _makeUiRenderer = ({url, uiWidth, uiHeight}) => {
  const loadPromise = Promise.all([
    new Promise((accept, reject) => {
      const iframe = document.createElement('iframe');
      iframe.src = 'https://render.exokit.xyz/';
      iframe.onload = () => {
        accept(iframe);
      };
      iframe.onerror = err => {
        reject(err);
      };
      iframe.setAttribute('frameborder', 0);
      iframe.style.position = 'absolute';
      iframe.style.width = `${uiWidth}px`;
      iframe.style.height = `${uiHeight}px`;
      iframe.style.top = '-4096px';
      iframe.style.left = '-4096px';
      document.body.appendChild(iframe);
    }),
    fetch(url)
      .then(res => res.text()),
  ]);

  let renderIds = 0;
  return {
    async render(templateData) {
      const [iframe, interfaceHtml] = await loadPromise;

      if (renderIds > 0) {
        iframe.contentWindow.postMessage({
          method: 'cancel',
          id: renderIds,
        });
      }

      const start = Date.now();
      const mc = new MessageChannel();
      iframe.contentWindow.postMessage({
        method: 'render',
        id: ++renderIds,
        htmlString: interfaceHtml,
        templateData,
        width: uiWidth,
        height: uiHeight,
        transparent: true,
        port: mc.port2,
      }, '*', [mc.port2]);
      const result = await new Promise((accept, reject) => {
        mc.port1.onmessage = e => {
          const {data} = e;
          const {error, result} = data;

          if (result) {
            console.log('time taken', Date.now() - start);

            accept(result);
          } else {
            reject(error);
          }
        };
      });
      return result;
    },
  };
};
const wristUiMesh = (() => {
  const uiWidth = 800;
  const uiHeight = 400;
  const uiWorldWidth = 0.2;
  const uiWorldHeight = uiWorldWidth * uiHeight/uiWidth;

  const mesh = _makeUiMesh({
    uiWidth,
    uiHeight,
    uiWorldWidth,
    uiWorldHeight,
  });
  const renderer = _makeUiRenderer({
    url: 'keyboard.html',
    uiWidth,
    uiHeight,
  });

  let text = '';
  let connected = false;
  mesh.setConnected = c => {
    connected = c;
    if (!c) {
      text = '';
    }
    mesh.update();
  };
  mesh.setText = t => {
    text = t;
    mesh.update();
  };
  mesh.onupdate = () => {
    let t = text;
    while (t.length < 4) {
      t += '-';
    }
    return renderer.render({
      text: t,
      connected,
    });
  };
  mesh.onpress = hoveredAnchor => {
    if (hoveredAnchor) {
      const {id} = hoveredAnchor;
      let match;
      if (id === 'enter') {
        document.getElementById('room-code-input').value = text;
        document.getElementById('connect-button').click();
      } else if (id === 'new') {
        document.getElementById('create-room-button').click();
      } else if (id === 'disconnect') {
        document.getElementById('disconnect-button').click();
      } else if (id && (match = id.match(/^key-([0-9]+)$/))) {
        const n = parseInt(match[1], 10);
        if (n === 8) {
          text = text.slice(0, -1);
          mesh.update();
        } else {
          if (text.length < 4) {
            const c = String.fromCharCode(n);
            text += c;
            mesh.update();
          }
        }
      }
      return true;
    } else {
      return false;
    }
  };
  return mesh;
})();
wristUiMesh.position.set(0.5, 0.5, 1);
scene.add(wristUiMesh);

const tradeUiMesh = (() => {
  const uiWidth = 2048;
  const uiHeight = 1024;
  const uiWorldWidth = 2;
  const uiWorldHeight = uiWorldWidth * uiHeight/uiWidth;

  const mesh = _makeUiMesh({
    uiWidth,
    uiHeight,
    uiWorldWidth,
    uiWorldHeight,
  });
  const renderer = _makeUiRenderer({
    url: 'trade.html',
    uiWidth,
    uiHeight,
  });

  let srcAddress = '0x5D4876215103302dB605F4259330f283AF2Cc1Db';
  let dstAddress = '';
  let srcValue = 0;
  let dstValue = 0;
  let srcLockedIn = false;
  let dstLockedIn = true;
  mesh.onupdate = () => {
    return renderer.render({
      srcAddress,
      dstAddress,
      srcValue: srcValue.toFixed(5),
      dstValue: dstValue.toFixed(5),
      srcLockedIn,
      dstLockedIn,
      allLockedIn: srcLockedIn && dstLockedIn,
      addresses,
    });
  };
  mesh.onpress = hoveredAnchor => {
    if (hoveredAnchor) {
      const {id} = hoveredAnchor;
      let match;
      if (id && (match = id.match(/^add-(-?[0-9\.]+)$/))) {
        const n = parseFloat(match[1]);
        if (n === 0) {
          srcValue = 0;
        } else {
          srcValue += n;
        }
        mesh.update();
      } else if (id && (match = id.match(/^address-(0x[0-9a-f]+)$/i))) {
        dstAddress = match[1];
        mesh.update();
      } else if (id === 'lock') {
        srcLockedIn = true;
        mesh.update();
      } else if (id === 'unlock') {
        srcLockedIn = false;
        mesh.update();
      } else if (id === 'confirm-trade') {
        console.log('confirm trade');
        // mesh.update();
      } else if (id === 'cancel-trade') {
        dstAddress = '';
        srcValue = 0;
        dstValue = 0;
        srcLockedIn = false;
        mesh.update();
      } else {
        // nothing
      }
      return true;
    } else {
      return false;
    }
  };
  return mesh;
})();
tradeUiMesh.position.set(-0.5, 1, 1);
scene.add(tradeUiMesh);

const rayMesh = (() => {
  const geometry = new THREE.CylinderBufferGeometry(0.002, 0.002, 1, 3, 1, false, 0, Math.PI*2)
    .applyMatrix4(new THREE.Matrix4().makeTranslation(0, 1/2, 0))
    .applyMatrix4(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI/2)));
  const material = new THREE.MeshBasicMaterial({
    color: 0x42a5f5,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.visible = false;
  mesh.frustumCulled = false;
  return mesh;
})();
scene.add(rayMesh);

// multiplayer

let channelConnection = null;
const peerConnections = [];
const _connectMultiplayer = async rid => {
  const roomId = rid || makeId();

  channelConnection = new XRChannelConnection(roomId);
  channelConnection.addEventListener('peerconnection', e => {
    const peerConnection = e.detail;

    bindPeerConnection(peerConnection, container);

    peerConnection.addEventListener('open', () => {
      peerConnections.push(peerConnection);
      document.getElementById('user-count-text').innerText = peerConnections.length + 1;
    });
    peerConnection.addEventListener('close', () => {
      peerConnections.splice(peerConnections.indexOf(peerConnection), 1);
      document.getElementById('user-count-text').innerText = peerConnections.length + 1;
    });
  });

  document.getElementById('room-code-text').innerText = roomId;
  wristUiMesh.setText(roomId);
  const href = `${window.location.protocol}//${window.location.host}${window.location.pathname}?r=${roomId}`;
  document.getElementById('room-link').href = href;

  history.replaceState(null, '', href);
};
const _disconnectMultiplayer = async () => {
  if (channelConnection) {
    channelConnection.disconnect()
    channelConnection = null;

    const href = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;
    history.replaceState(null, '', href);
  }
};
window.addEventListener('beforeunload', _disconnectMultiplayer);

const header = document.getElementById('header');
const _clearMultiplayerClasses = () => {
  ['connected', 'dialog'].forEach(c => {
    header.classList.remove(c);
  });
};
document.getElementById('create-room-button').addEventListener('click', async e => {
  await _connectMultiplayer();

  _clearMultiplayerClasses();
  header.classList.add('connected');
  wristUiMesh.setConnected(true);
});
document.getElementById('use-code-button').addEventListener('click', e => {
  _clearMultiplayerClasses();
  header.classList.add('dialog');
  document.getElementById('room-code-input').value = '';
});
document.getElementById('connect-button').addEventListener('click', async e => {
  await _connectMultiplayer(document.getElementById('room-code-input').value);

  _clearMultiplayerClasses();
  header.classList.add('connected');
  wristUiMesh.setConnected(true);
});
document.getElementById('cancel-connect-button').addEventListener('click', e => {
  _clearMultiplayerClasses();
});
document.getElementById('disconnect-button').addEventListener('click', async e => {
  await _disconnectMultiplayer();

  _clearMultiplayerClasses();
  wristUiMesh.setConnected(false);
});

// addressbook

let addresses = [];
document.getElementById('addresses').addEventListener('mousedown', e => {
  e.preventDefault();
});
const _updateAddressBook = () => {
  const addressesEl = document.getElementById('addresses');
  addressesEl.innerHTML = addresses.map(address => {
    return `<div class=address address="${address}"">
      <a class=value>${address}</a>
      <a class="button secondary">- Remove</a>
    </div>`;
  }).join('\n');
  const addressEls = Array.from(addressesEl.querySelectorAll('.address'));
  for (let i = 0; i < addressEls.length; i++) {
    const addressEl = addressEls[i];
    const address = addressEl.getAttribute('address');
    const buttonEl = addressEl.querySelector('.button');
    addressEl.addEventListener('click', e => {
      e.stopPropagation();

      console.log('click address', address); // XXX
    });
    buttonEl.addEventListener('click', e => {
      e.stopPropagation();

      addresses = addresses.filter(a => a !== address);
      localStorage.setItem('addressbook', JSON.stringify(addresses));
      _updateAddressBook();
    });
  }
  tradeUiMesh.update();
};
{
  const keystoreString = localStorage.getItem('wallet');
  if (keystoreString) {
    header.classList.add('locked');
  }

  const addressbookString = localStorage.getItem('addressbook');
  if (addressbookString) {
    addresses = JSON.parse(addressbookString);
    _updateAddressBook(addresses);
  }
}
const addressInput = document.getElementById('address-input');
addressInput.id = 'fake' + Math.random();
document.getElementById('add-address-button').addEventListener('click', e => {
  const address = addressInput.value;
  console.log('add address', address, /^0x[a-f0-9]{40}$/i.test(address), !addresses.includes(address));
  if (/^0x[a-f0-9]{40}$/i.test(address) && !addresses.includes(address)) {
    addresses.push(address);
    localStorage.setItem('addressbook', JSON.stringify(addresses));
    _updateAddressBook();
  }

  addressInput.focus();
});

// wallet

let keystore = null;
async function exportSeed(ks, password) {
  const p = makePromise();
  ks.keyFromPassword(password, function (err, pwDerivedKey) {
    const seed = keystore.getSeed(pwDerivedKey);
    p.accept(seed);
  });
  return await p;
}
const _createKeystore = async (seedPhrase, password) => {
  // var seedPhrase = lightwallet.keystore.generateRandomSeed();

  const p = makePromise();
  lightwallet.keystore.createVault({
    password,
    seedPhrase, // Optionally provide a 12-word seed phrase
    // salt: fixture.salt,     // Optionally provide a salt.
                               // A unique salt will be generated otherwise.
    hdPathString: `m/44'/60'/0'/0`,    // Optional custom HD Path String
  },
  (err, ks) => {
    // console.log('got keystore', err, ks);
    // window.ks = ks;

    if (!err) {
      ks.keyFromPassword(password, function (err, pwDerivedKey) {
        if (!err) {
          ks.generateNewAddress(pwDerivedKey, 1);

          p.accept(ks);
        } else {
          p.reject(err);
        }
      });
    } else {
      p.reject(err);
    }
  });
  const ks = await p;
  ks.exportSeed = exportSeed.bind(null, ks, password);
  return ks;
};
const _exportKeyStore = ks => ks.serialize();
const _importKeyStore = async (s, password) => {
  const ks = lightwallet.keystore.deserialize(s);

  const p = makePromise();
  ks.keyFromPassword(password, function (err, pwDerivedKey) {
    if (!err) {
      if (ks.isDerivedKeyCorrect(pwDerivedKey)) {
        p.accept();
      } else {
        p.reject(new Error('invalid password'));
      }
    } else {
      p.reject(err);
    }
  });
  await p;
  ks.exportSeed = exportSeed.bind(null, ks, password);
  return ks;
  /* // Some methods will require providing the `pwDerivedKey`,
  // Allowing you to only decrypt private keys on an as-needed basis.
  // You can generate that value with this convenient method:
  ks.keyFromPassword(password, function (err, pwDerivedKey) {
    if (err) throw err;

    // generate five new address/private key pairs
    // the corresponding private keys are also encrypted
    ks.generateNewAddress(pwDerivedKey, 1);
    const addresses = ks.getAddresses();

    ks.passwordProvider = function (callback) {
      const pw = prompt("Please enter password", "Password");
      callback(null, pw);
    };

    // Now set ks as transaction_signer in the hooked web3 provider
    // and you can start using web3 using the keys/addresses in ks!
  });

  _clearWalletClasses();
  header.classList.add('unlocked'); */
};
const _clearWalletClasses = () => {
  ['import', 'locked', 'unlocked'].forEach(c => {
    header.classList.remove(c);
  });
};
document.getElementById('import-key-button').addEventListener('click', async e => {
  document.getElementById('password-input').value = '';
  document.getElementById('seed-phrase-input').value = '';

  _clearWalletClasses();
  header.classList.add('import');
});
document.getElementById('create-wallet-button').addEventListener('click', e => {
  document.getElementById('password-input').value = '';
  document.getElementById('seed-phrase-input').value = lightwallet.keystore.generateRandomSeed();

  _clearWalletClasses();
  header.classList.add('import');
});
document.getElementById('import-button').addEventListener('click', async e => {
  // the seed is stored encrypted by a user-defined password
  const seedPhrase = document.getElementById('seed-phrase-input').value;
  const password = document.getElementById('password-input').value;
  // var seedPhrase = lightwallet.keystore.generateRandomSeed();

  keystore = await _createKeystore(seedPhrase, password);
  localStorage.setItem('wallet', _exportKeyStore(keystore));
  const balance = await web3.eth.getBalance(keystore.addresses[0]);

  document.getElementById('seed-phrase-input').value = '';
  document.getElementById('password-input').value = '';
  document.getElementById('address-text').innerText = `0x${keystore.addresses[0]}`;
  document.getElementById('balance-text').innerText = `${balance} ETH`;

  _clearWalletClasses();
  header.classList.add('unlocked');
});
[
  'seed-phrase-input',
  'password-input',
].forEach(k => {
  document.getElementById(k).addEventListener('keydown', e => {
    if (e.which === 13) {
      document.getElementById('import-button').click();
    }
  });
});
document.getElementById('cancel-import-button').addEventListener('click', e => {
  _clearWalletClasses();
});
document.getElementById('unlock-wallet-button').addEventListener('click', async e => {
  const keystoreString = localStorage.getItem('wallet');
  const password = document.getElementById('password-unlock-input').value;

  keystore = await _importKeyStore(keystoreString, password);
  const balance = await web3.eth.getBalance(keystore.addresses[0]);

  document.getElementById('password-unlock-input').value = '';
  document.getElementById('address-text').innerText = `0x${keystore.addresses[0]}`;
  document.getElementById('balance-text').innerText = `${balance} ETH`;

  _clearWalletClasses();
  header.classList.add('unlocked');
});
document.getElementById('password-unlock-input').addEventListener('keydown', e => {
  if (e.which === 13) {
    document.getElementById('unlock-wallet-button').click();
  }
});
document.getElementById('download-key-button').addEventListener('click', async e => {
  const seed = await keystore.exportSeed();
  const a = document.createElement('a');
  const b = new Blob([seed], {
    type: 'text/plain',
  });
  const u = URL.createObjectURL(b);
  a.href = u;
  a.download = 'seed.txt';
  a.click();
  URL.revokeObjectURL(u);
});
document.getElementById('forget-wallet-button').addEventListener('click', e => {
  localStorage.removeItem('wallet');
  _clearWalletClasses();
});
document.getElementById('lock-wallet-button').addEventListener('click', e => {
  keystore = null;

  _clearWalletClasses();
  header.classList.add('locked');
});

// engine

const socket = new WebSocket(`ws://localhost:3000/`);
socket.onopen = async () => {
  console.log('socket open', socket);

  /* const result = await socket.request('test', [
    new ArrayBuffer(8)
  ]);
  console.log('got result', result); */
};
socket.binaryType = 'arraybuffer';
const cbs = [];
const socketData = [];
let binaryMode = null;
let handlePose = null;
let handleMirrorTexture = null;
socket.onmessage = m => {
  if (typeof m.data === 'string') {
    if (m.data === 'pose' || m.data === 'mirrorTexture') {
      binaryMode = m.data;
    } else {
      m = JSON.parse(m.data);
      const cb = cbs.shift();
      cb && cb(m);
    }
  } else {
    // console.log('got message', m.data);
    if (binaryMode === 'pose') {
      socketData.push(m.data);
      if (socketData.length >= 3) {
        handlePose && handlePose.apply(null, socketData);
        socketData.length = 0;
        binaryMode = null;
      }
    } else if (binaryMode === 'mirrorTexture') {
      socketData.push(m.data);
      if (socketData.length >= 3) {
        handlePose && handleMirrorTexture.apply(null, socketData);
        socketData.length = 0;
        binaryMode = null;
      }
    } else {
      console.warn('got unexpected binary message');
    }
  }
};
socket.onclose = () => {
  console.log('socket close', socket);
};
socket.request = async (method, args) => {
  const bins = [];
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg instanceof ArrayBuffer || ArrayBuffer.isView(arg)) {
      bins.push(arg);
      args[i] = null;
    }
  }

  const p = makePromise();
  cbs.push(o => {
    const {error, result} = o;
     if (!error) {
       p.accept(result);
     } else {
       p.reject(error);
     }
  });
  socket.send(JSON.stringify({
    method,
    args,
  }));
  for (let i = 0; i < bins.length; i++) {
    socket.send(bins[i]);
  }
  return await p;
};

handleMirrorTexture = (w, h, d) => {
  w = new Uint32Array(w)[0];
  h = new Uint32Array(h)[0];
  console.log('got mirror texture', w, h, d);
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  canvas.style.width = '800px';
  canvas.style.height = '800px';
  const ctx = canvas.getContext('2d');
  const imageData = ctx.createImageData(w, h);
  imageData.data.set(new Uint8ClampedArray(d));
  ctx.putImageData(imageData, 0, 0);
  document.body.appendChild(canvas);
};

// window.addEventListener('load', async e => {
const enterXrButton = document.getElementById('enter-xr-button');
const triggerDowns = [false, false];
const gripDowns = [false, false];
let scaleState = null;
const lastSqueezes = [false, false];
function onSessionStarted(session) {
  session.addEventListener('end', onSessionEnded);

  renderer.xr.setSession(session);

  currentSession = session;

  const controllerModelFactory = new XRControllerModelFactory();
  for (let i = 0; i < 2; i++) {
    const controller = renderer.xr.getController(i);
    controller.addEventListener('connected', e => {
      controller.userData.data = e.data;
    });
    controller.addEventListener('selectstart', e => {
      if (controller.userData.data && controller.userData.data.handedness === 'right') {
        wristUiMesh.press() || tradeUiMesh.press();
        // _beginTool(true, false, false);
      }
      triggerDowns[i] = true;
    });
    controller.addEventListener('selectend', e => {
      /* if (controller.userData.data && controller.userData.data.handedness === 'right') {
        _endTool(true, false, false);
      } */
      triggerDowns[i] = false;
    });

    const controllerGrip = renderer.xr.getControllerGrip(i);
    controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
    controllerGrip.addEventListener('squeezestart', e => {
      /* if (controller.userData.data && controller.userData.data.handedness === 'right') {
        _beginTool(false, true, false);
      }
      const oldGripDownsAll = gripDowns.every(gripDown => gripDown); */
      gripDowns[i] = true;
      /* const newGripDownsAll = gripDowns.every(gripDown => gripDown);
      if (newGripDownsAll && !oldGripDownsAll) {
        _commitMiningMeshes();
        
        scaleState = {
          startPosition: renderer.xr.getControllerGrip(0).position.clone()
            .add(renderer.xr.getControllerGrip(1).position)
            .divideScalar(2),
          startDirection: renderer.xr.getControllerGrip(0).position.clone()
            .sub(renderer.xr.getControllerGrip(1).position)
            .normalize(),
          startWorldWidth: renderer.xr.getControllerGrip(0).position
            .distanceTo(renderer.xr.getControllerGrip(1).position),
          containerStartPosition: container.position.clone(),
          containerStartQuaternion: container.quaternion.clone(),
          containerStartScale: container.scale.clone(),
          containerStartMatrix: container.matrix.clone(),
        };
      } */
    });
    controllerGrip.addEventListener('squeezeend', e => {
      /* if (controller.userData.data && controller.userData.data.handedness === 'right') {
        _endTool(false, true, false);
      } */
      gripDowns[i] = false;
      /* const newGripDownsAll = gripDowns.every(gripDown => gripDown);
      if (!newGripDownsAll) {
        scaleState = null;
      } */
    });
    scene.add(controllerGrip);
  }

  rig && rig.decapitate();
}
function onSessionEnded() {
  currentSession.removeEventListener('end', onSessionEnded);

  currentSession = null;
}
enterXrButton.addEventListener('click', e => {
  e.preventDefault();
  e.stopPropagation();
  
  if (currentSession === null) {
    // WebXR's requestReferenceSpace only works if the corresponding feature
    // was requested at session creation time. For simplicity, just ask for
    // the interesting ones as optional features, but be aware that the
    // requestReferenceSpace call will fail if it turns out to be unavailable.
    // ('local' is always available for immersive sessions and doesn't need to
    // be requested separately.)
    var sessionInit = {
      optionalFeatures: [
        'local-floor',
        'bounded-floor',
      ],
    };
    navigator.xr.requestSession('immersive-vr', sessionInit).then(onSessionStarted);
  } else {
    currentSession.end();
  }
});

const localRaycaster = new THREE.Raycaster();
const _updateRaycasterFromMouseEvent = (raycaster, e) => {
  const mouse = new THREE.Vector2(( ( e.clientX ) / window.innerWidth ) * 2 - 1, - ( ( e.clientY ) / window.innerHeight ) * 2 + 1);
  raycaster.setFromCamera(mouse, camera);
  /* if (selectedTool === 'brush') {
    raycaster.ray.origin.add(raycaster.ray.direction);
  } */
};
const _updateRaycasterFromObject = (raycaster, o) => {
  raycaster.ray.origin.copy(o.position);
  raycaster.ray.direction.set(0, 0, -1).applyQuaternion(o.quaternion);
};
const _updateIntersections = raycaster => {
  const intersected = [wristUiMesh, tradeUiMesh].some(uiMesh => {
    const intersections = raycaster.intersectObject(uiMesh);
    if (intersections.length > 0 && intersections[0].distance < 3) {
      const [{distance, uv}] = intersections;
      rayMesh.position.copy(raycaster.ray.origin);
      rayMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), raycaster.ray.direction);
      rayMesh.scale.z = distance;
      rayMesh.visible = true;

      // orbitControls.enabled = false;

      return uiMesh.intersect(uv);
    } else {
      rayMesh.visible = false;
      
      // orbitControls.enabled = selectedTool === 'camera';

      return uiMesh.intersect(null);
    }
  });
  orbitControls.enabled = cameraMode === 'orbit' && !intersected;
};

const velocity = new THREE.Vector3();
function animate() {
  orbitControls.enabled && orbitControls.update();

  if (currentSession) {
    for (let i = 0; i < 2; i++) {
      const controller = renderer.xr.getController(i);
      if (controller.userData.data) {
        if (controller.userData.data.handedness === 'left') {
          const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI/2)
            .multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI/2));
          wristUiMesh.quaternion.copy(controller.quaternion)
            .multiply(q);
          wristUiMesh.position.copy(controller.position)
            .add(new THREE.Vector3(0, 0, 0.05).applyQuaternion(wristUiMesh.quaternion));
        } else if (controller.userData.data.handedness === 'right') {
          _updateRaycasterFromObject(localRaycaster, controller);
        }
      }
    }

    updatePlayerFromXr(renderer.xr, camera);
  } else if (cameraMode !== 'orbit') {
    const speed = 0.015 * (keys.shift ? 3 : 1);
    const cameraEuler = camera.rotation.clone();
    cameraEuler.x = 0;
    cameraEuler.z = 0;
    const extraVelocity = new THREE.Vector3();
    if (keys.left) {
      extraVelocity.add(new THREE.Vector3(-1, 0, 0).applyEuler(cameraEuler));
    }
    if (keys.right) {
      extraVelocity.add(new THREE.Vector3(1, 0, 0).applyEuler(cameraEuler));
    }
    if (keys.up) {
      extraVelocity.add(new THREE.Vector3(0, 0, -1).applyEuler(cameraEuler));
    }
    if (keys.down) {
      extraVelocity.add(new THREE.Vector3(0, 0, 1).applyEuler(cameraEuler));
    }
    if (extraVelocity.length() > 0) {
      extraVelocity.normalize().multiplyScalar(speed);
    }
    velocity.add(extraVelocity);
    camera.position.add(velocity);
    velocity.multiplyScalar(0.7);
    
    orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, 0, -1.5).applyQuaternion(camera.quaternion));
    
    updatePlayerFromCamera(camera);
  } else {
    updatePlayerDefault();
  }
  
  _updateIntersections(localRaycaster);

  for (let i = 0; i < peerConnections.length; i++) {
    const peerConnection = peerConnections[i];
    peerConnection.rig && peerConnection.rig.update();
  }

  /* tickObjectScript(objectState);

  if (ammo) {
    ammo.simulate();
    for (let i = 0; i < objectMeshes.length; i++) {
      ammo.updateObjectMesh(objectMeshes[i]);
    }
  } */

  const thirdperson = cameraMode === 'thirdperson';
  let oldCameraPosition;
  if (thirdperson) {
    oldCameraPosition = camera.position.clone();
    camera.position.add(new THREE.Vector3(0, 0, 2).applyQuaternion(camera.quaternion));
  }
  renderer.render(scene, camera);
  if (thirdperson) {
    camera.position.copy(oldCameraPosition);
  }
}
renderer.setAnimationLoop(animate);

window.addEventListener('mousemove', e => {
  if (!currentSession) {
    _updateRaycasterFromMouseEvent(localRaycaster, e);
  }
});
window.addEventListener('mousedown', e => {
  if (!currentSession) {
    wristUiMesh.press() || tradeUiMesh.press();
  }
});

navigator.xr && navigator.xr.isSessionSupported('immersive-vr').then(supported => {
  if (supported) {
    renderer.xr.enabled = true;
    enterXrButton.classList.remove('disabled');
  } else {
    // nothing
  }
});

let avatarObject = null;
let hmdObject = null;
const controllerObjects = [null, null];
document.getElementById('enter-overlay-button').addEventListener('click', async e => {
  await socket.request('startRenderer', []);
  console.log('render started');

  const geometry = new THREE.CylinderBufferGeometry(0, 0.1, 0.1, 3, 1);
  const colors = new Float32Array(geometry.attributes.position.array.length);
  for (let i = 0; i < colors.length; i += 3) {
    colors[i+2] = 1;
  }
  /* hmdObject = await socket.request('addObject', [
    geometry.attributes.position.array,
    geometry.attributes.normal.array,
    colors,
    geometry.attributes.uv.array,
    geometry.index.array,
  ]); */
  controllerObjects[0] = await socket.request('addObject', [
    geometry.attributes.position.array,
    geometry.attributes.normal.array,
    colors,
    geometry.attributes.uv.array,
    geometry.index.array,
  ]);
  controllerObjects[1] = await socket.request('addObject', [
    geometry.attributes.position.array,
    geometry.attributes.normal.array,
    colors,
    geometry.attributes.uv.array,
    geometry.index.array,
  ]);
  console.log('got objects', hmdObject, controllerObjects[0], controllerObjects[1]);
  
  const res = await fetch('../data/avatar.glb');
  const arrayBuffer = await res.arrayBuffer();
  console.log('model fetched');
  avatarObject = await socket.request('addModel', [
    'model',
    arrayBuffer,
  ]);
  console.log('model added');
});
handlePose = (hmd, left, right) => {
  if (avatarObject) {
    updatePlayerFromArrays(renderer.xr, new Float32Array(hmd), new Float32Array(left), new Float32Array(right));
    const boneTexture = getRigBoneTexture();
    if (boneTexture) {
      // console.log('submit bones', boneTexture);
      socket.request('updateObjectBoneTexture', [
        avatarObject.id,
        boneTexture.buffer,
      ]);
    }
  }
  if (hmdObject) {
    socket.request('updateObjectMatrix', [
      hmdObject.id,
      hmd,
    ]);
  }
  if (controllerObjects[0]) {
    socket.request('updateObjectMatrix', [
      controllerObjects[0].id,
      left,
    ]);
  }
  if (controllerObjects[1]) {
    socket.request('updateObjectMatrix', [
      controllerObjects[1].id,
      right,
    ]);
  }
};
// });

window.addEventListener('resize', e => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

</script>
</body>
</html>